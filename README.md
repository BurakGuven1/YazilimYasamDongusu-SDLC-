# YazilimYasamDongusu-SDLC-
Software Development Life Cycle
Yazılım Yaşam Döngüsü Nedir? 

 

Genel olarak yazılımlar, geliştirilirken belirli bazı süreçlerden geçerler. Yazılım yaşam döngüsü, ihtiyaç durumundan doğan ve sonrasında bakımına kadar geçen döngüdür. 

Aşağıdaki modellemede yazılım geliştirmenin ilk evresi olan planlama aşamasından son evresi olan bakım aşamasına kadar sürecine bakabiliriz. 


 

Planlama: Bir projeyi planlamadan yola başlamak ne kadar mantıklıdır? Bence hiç değil. O yüzden ilk önce planlamayla başlayalım. Yazılım geliştirmenin ilk adımıdır. Bu aşamada müşterinin gereksinimleri toplanır. Projenin maliyeti, temel ihtiyaçları, yararları ve planlaması belirlenir. 



Analiz: Planlama aşamasının devamı olarak analiz safhası gelir. Bu safhadaki en önemli kısım planlamadaki kararlarımızı daha ayrıntılı inceleyerek doküman oluşturmaktır. Yani atalarımızın da dediği gibi ‘Söz uçar yazı kalır.’ Analiz safhasının diğer önemli bir görevi ise yazılımın gereksinimlerini, maliyetlerini, müşterinin ihtiyaçlarını kesinleştirmektir. Bu süreçte yazılım ekibiyle ve müşteriyle güzel bir iletişimde olmanızda gayet önemsenecek bir durumdur.  

 
 

Tasarım: Bu safha yazılımın dış dünyaya, hayata geçirilmesinin ilk adımıdır. Planlama ve analiz kısımlarındaki “Ne yapacağız?” sorusu tasarımda “Nasıl yapacağız?” şekline dönüşür. Yazılım yaşam döngüsünün en temel sorularından biri olan “Gereksinimleri nasıl karşılarız?” sorusuna cevabı bu safhada arar ve buluruz. Her kesimin bilebileceği bir örnek verecek olursak arayüz tasarımı en somut örnek olacaktır. Yazılım projesini müşteriye en etkili ve en basit şekilde anlatan kısım tasarımdır. 

 

Uygulama: Fikirler, uğraşlar güzel ve önemlidir fakat siz bunları uygulamaya dökmediğinizde ne anlamı kalır değil mi?  Planlama, analiz ve tasarım safhalarıyla projenizin attığınız sağlam temellerini uygulama safhasında yükseltmeye başlamak gerekir. Bu evrede genellikle bir an önce hedefe ulaşma heyecanı oluştuğundan kodlarken acele edilir fakat en dikkat edilecek kısımdır çünkü farklı kişilerin anlayacağı şekilde ve bakımı kolay olması için “Clean Code” kurallarında yazılmalıdır. Bunun yanında kodlama standartlarına da uymayı tavsiye ederim çünkü herhangi biri koda baktığında kolayca anlamalı ve bu X kişisinin kodu diyebilmelidir yani kod kişiye özgü olmalıdır. 

Tabii ki uygulamadaki tek önemli kriter kod değildir bunun yanı sıra test kısmı da gayet önemlidir. 

Teste önem verilen bir yazılım projesinde hata yapma oranı, maliyet gibi birçok durumdan en optimum 	şekilde yararlanılır. 

 

Teslim ve Bakım: Tüm testlerden başarıyla geçmiş bir yazılım projesi artık çıkarılmaya hazırdır. Tabii ki çıkardık işimiz bitti gibi sakın düşünmeyin. Sadece ürünü sunmak yetmez bunun yanında kullanım kılavuzu gerekir. Yazılımcı daha sonra bu yazılımın müşterinin isteklerini doğrultusunda yeni versiyonlar getirerek bakımını yapar. 

 

Yazılım Süreç Modelleri 

 

Bu modeller yazılım projesi üretilirken yazılım ekibine rehber olan modellerdir. Süreçlere ilişkin 	ayrıntılar ile ilgilenmezler. Dilerseniz bu modelleri daha yakından tanıyalım: 

 

Kodla ve Düzelt (Code and Fix): Evet acemi yazılımcıların sık kullandığı kodla ve düzelt modeliyle başlayalım. Şu an üniversite okuyorsanız veya ilk iş deneyiminizi yaşıyorsanız sizde bu modeli kullanıyorsunuzdur. 

 

Kimler Kullanır? : Genelde küçük çaplı küçük çaplı projelerde kullanılır. Tek kişinin veya birkaç 	kişinin yazabildiği projelerde kullanılır. Üniversite öğrencilerinde ise bu yöntem sık kullanılır. 

 

Hangi Durumlarda Kullanılır? : Aklımda kalmasın çok zaman almasın planlama, test, bakım 	ile uğraşmayayım dediğiniz projeler için biçilmiş kaftandır. Ancak müşterinin ne zaman sizden yeni bir 	versiyon isteyeceği ve kodda herhangi bir hata çıkmayacağı kesin olmadığı için bu modeli kullanmak 	ileride başınızı ağrıtabilir.Aman dikkat! 

 

Şelale Modeli (Waterfall Model): Kodla ve Düzelt modeline göre daha profesyonel model olan Şelale Modeli,kademeli bir biçimde ilerleyen modeldir.Çağlayan modeli olarak da bilinir. Kullanımı ve anlaşırlığı ve yönetimi kolaydır.Aşamaların en az birer kez tekrarlanmasıyla süreç ilerler.Şelale modelinin dezavantajı büyük projelerde statik olduğu için geri dönüşlerde sıkıntıya yol açmasıdır. Bu sebepten dolayı günümüzde kullanımı gittikçe azalmaktadır. 

 

      Kimler Kullanır? : Şirketler, büyük olmayan proje yönetimlerinde ve sürekli değişim istemeyen           projelerde kullanır. 

 

      Hangi Durumlarda Kullanılır? : Küçük projelerde birikimli bir şekilde müşterinin dahil                 olmayacağı düşünülüyor ve isteniyorsa bu proje size tam uygundur. Aynı zamanda yazılımınız gayet           hızlı sonuçlanır. 

 

V-Modeli : Süreç aşamasında kodlamadan sonra yukarıya doğru eğim alıp V şeklini alır adı da buradan gelmektir.Bu modelin V gibi 2 kolu vardır. V nin sol kolu üretimi sağ tarafı ise sınama kısmından oluşur. Hadi biraz da avantaj ve dezavantajlarına bakalım, belki sizin projenize uyabilecek bir modeldir.V-Modelinin en büyük avantajlarından biri proje yönetimi aşırı basittir ve kullanımı oldukça basittir. Dezavantajlarına bakacak olursak aynı zamanda gerçekleştirilebilecek olaylara pek imkan tanımaz ve risk çözümleme aktiviteleri içermez. 

 

      Kimler Kullanır? : Şelale modeli bu modele çok benzer ve aynı kullanıcılar 	                                kullanabilirler.Test ve tanıma önem veren yazılımcılar için önerebilirim. 

 

       Hangi Durumlarda Kullanılır? : Geri dönüşlerin çok nadir olduğu bu modelde tabii ki bu                çok riskli fakat daha çok test aşamasına değer vermek istiyorsanız bu proje sizin için gayet uygundur. 

 

Evrimsel Geliştirme (Evoluationary Development) Modeli : Gereksinimleri kesinleştiremiyorsanız bu model tam size göre. Bu model ilk tam ölçekli modeldir.Gereksinimi anlamayı basitleştirmesiyle birlikte risk ve hata oranını da en aza indirir. Bu modelin zayıf yanıysa değişime pek imkan vermez ve bakımı oldukça maliyetlidir. Müşterinin geri dönütüyle çalıştığı için yavaş gerçekleşmesi de cabası. 

 

      Kimler Kullanır? : Müşterinin gereksinimleri tam belirlenemediği veya anlaşılamadığı 	                 senaryolarda kullanılır. Genellikle yazılımcılar bakımı maliyetli olduğu için bu modelden uzak                     dururlar. 

 

      Hangi Durumlarda Kullanılır? :  Projelerinizin bütün hali size korkunç gelebilir ve bu                   durumda büyük projenizi küçük parçalara ayırmak isterseniz bu model sizin için gayet uygun                       olacaktır. Kısacası “Böl parçala yönet” mentalitesini benimseyen biriyseniz harika bir model! 

 

Prototipleme (Prototyping) Modeli : Modelin amacı isminden de anlayacağınız üzere bir prototip üzerine birikim yaparak geliştirmektir. Evrimsel Geliştirme Modeline zıt olarak gereksinimler burada net bir biçimde belirlenmelidir. İyi yönünden bakacak olursak modele kullanıcı sistem gereksinimlerini görebilir ve karmaşıklığı, yanlış anlamaları engeller. Kötü yönü ise müşteri prototipten son ürün gibi görünüm ve etki bekler. Düzeltme aşamasına bağlı olarak performansı düşebilir. 

 

Kimler Kullanır? : Hızlı ve etkili bir proje süreci isteyen yazılım ekibi için kullanılabilir bir 	modeldir. Aman dikkat prototipinizi göz arkası etmeyin müşteri hoşnut olmayabilir. 

 

Hangi Durumlarda Kullanılır? : Bir an önce gözünüzle somut bir şey görmek istiyorsanız hedefinize giderken yaptığınız işi görmeniz sizin performansınızı arttırdığınızı düşünüyorsanız Prototipleme Modeli kullanmanız kaçınılmaz olacaktır. Üstelik dökümantasyonu sevmiyorsanız kullanabilirsiniz. 

 

· Spiral (Helezonik) Model : Planlama, Risk Analizi, Üretim, Kullanıcı Değerlendirmesi şeklinde 4 ana safhadan oluşur. Spiral model daha çok büyük çaplı projeler içindir. Planlama kısmında üretilecek ara ürün için planlama, amaç belirleme, bir önceki adımda üretilen ara ürün ile bütünleştirme işlemleri yapılır. Risk Analizi bölümünde ise risk seçenekleri araştırılır ve riskler belirlenir. Üretim kısmında ara ürün üretilir. Kullanıcı Değerlendirmesinde ise ara ürün ile ilgili olarak kullanıcı tarafından sınama ve değerlendirmeler yer alır. 

 

Kimler Kullanır? : Kullanıcılar sistemi erken görme niyetindeyse ve riskli kısımları bir an önce aklımdan sileyim diyorsa bu model uygun olacaktır. 

 

Hangi Durumlarda Kullanılır? : Elimizde yazılı metin olsun ve zamanımız var diyebilen yazılım ekipleri rahatça kullanabilecekleri bir modeldir. Ara adımlar sık olduğu için çok fazla dökümantasyon gerektirir ve büyük ölçekteki projeler için kullanılır. 

 

Formal Sistem Geliştirme Modeli (Formal System Development) : Yazılım tasarım ve gerçekleştirmesiyle ilgili matematiksel bir tekniktir. Bu modelin asıl amacı karmaşık sistemleri ve programları geliştirmektir. Bu karmaşık olduğu anlamına gelmez aksine basit bir modeldir. Asıl gaye doğruluktur bu yoldan şaşmamakla birlikte yazılım birikimlerle geliştirilir. Uzun zaman aldığını ve maliyetli olduğunu unutmayalım.  

 

Kimler Kullanır? :  Genelde büyük projelerle uğraşan, kaliteli hata yapmak istemeyen yazılım şirketleri kullanır. 

 

Hangi Durumlarda Kullanılır? : Hatasız bir proje üretmek isteyen bir yazılım ekibiyseniz bu modeli rahatça kullanabilirsiniz fakat zamanınızdan çok alabilir ve cebinizi hayli yakabilir. 

 

Artımsal Geliştirme Modeli ( Incremental Development) : Planlama, analiz ve tasarım aşamalarından sonra temel bir yapı oluşturalarak bir sürüm üretilir ve sistem zamanla sürekli geliştirilerek müşterinin isteğine göre veya hata varsa hatalar düzeltilerek süreç ilerletilir. Tüm projenin başarısız olma riskini ortadan kaldırır. 

 

Kimler Kullanır? : Müşterinin isteklerine önem veren aynı zamanda bir hatada yazılımın yok olmasını istemeyen, sistematik ilerleyen yazılım şirketleri veya ekipleri kullanır. 

 

Hangi Durumlarda Kullanılır? : En önemli sistem özelliği olan daha fazla sınama (test) imkanı bulmak isteyenler için tercih edilebilir. Divide and Conquer (Böl ve Yönet) yaklaşımına kendini yakın bulan ekipler tarafından kullanılabilir bir modeldir. Hata yapılmak istenmeyen projelerde kullanılan en yaygın modeldir. 

 

Birleşik Süreç (Unified Process) : Bu yöntem nesneye yönelim yazılım için bütün modellerin iyi yanlarından tane tane seçen ve kendine uygulayan harika bir süreçtir. Bu süreç aynı zamanda yinelemeli ve arttırmalıdır. Şimdi Birleşik Süreçin geliştirme aşamalarına bakalım :  

 

Başlangıç: Başlangıç aşamasında vizyon kararı, fizibilite çalışmaları ve tamam ya da devam kararları alınır.  

Ayrıntılandırma: Bu aşamada daha realist çözümleme, temel yapının ve yüksek risk barındıran bölümlerin yinelemeli olarak oluşturulmasıyla uğraşılır.  

Tamamlama: Tamamlama safhasında ayrıntılandırmaya kıyasla daha az riskli ve düşük öncelikli bölümlerin yinelemeli olarak gerçeklenmesidir.  

Yayım: Yayımda bildiğiniz üzere müşterinin önüne sunulan beta testleriyle müşterinin tepki ve davranışları kontrol edilip son rötüşlar tamamlandıktan sonra piyasaya sürülme aşamasıdır. 

 

Kimler Kullanır? : Dökümantasyonu aşırı kullanan bir süreç olduğu için maliyetli ve yazılım 	ekibinin kişi sayısını arttıracak bir yazılım yapacak olanlar kullanır. 

Hangi Durumlarda Kullanılır? : Dökümantasyon anlamında zengin olan bu yöntem büyük 	ölçekli projelerde ve değişime açık yazılımlarda kullanılır. Diyorsanız ki “Değişmeyen tek şey 	değişimdir.” Bu süreçten geçmenizi şiddetle tavsiye ederim.  

 

Çevik Modeller (Agile Programming) : Evet gelelim günümüzün eski modellerinden 	ve süreçlerinden arınmış sürekli kendini değiştiren ve geliştiren bir modele. Bu modelde yazılımcının 	motivasyonundan tutun da yazılımın bir saniye hızlı çalışmasını bile düşündüğü bir modeldir. Takım 	çalışmasının hat safhada olduğu kaliteli yazılımların hızlı bir şekilde geliştirildiği en iyi mühendislik 	uygulamalarını sağlayan müşterinin isteklerini sağlayan bir yazılım geliştirme topluluğudur.Şimdi de 	Çevik Modellerin değerlerine ve prensiplerine bakalım :  

Değerler: 

Süreçler ve araçlar arasında sürekli bir etkileşim vardır. 

Dökümantasyonlar kabarık olup süreçte çok etkilidir. 

Anlaşılan taahhüt üzerinden müşteriyle birlikte çalışılır. 

Değişiklik yönetimi plan kurarak yönetilir. 

Prensipler: 

Teslimi hızlandırarak müşterinin memnun olması sağlanır. 

Çalışan yazılımlar uzun süreler yerine kısa sürede müşteriye sunulur.. 

Gereksinimlerde yapılan değişiklikler dikkate alınır. 

Yazılım ekibi içinde veya müşteriyle beraber yüz yüze görüşmek sürecin hızı için çok önemlidir. 

Proje güvenilir ve motivasyonu yüksek kişiler üzerine kurulur. 

Teknik başarı ve iyi tasarım olursa ekibi motive etmek önemlidir. 


Şimdi de Çevik Modelin alt yapılanması gibi olan XP ve Scrum a bakalım. 

 

          XP (Extreme Programming)  : Kent Beck tarafından 1999 yılında bir yazılım                            geliştirilme disiplini olarak çıkarılmıştır. XP deki önemli kriterler grup içi iletişime ve geri dönüşlere 	önem vermektir. İletişim o kadar iyidir ki müşteri de yazılım ekibinin bir parçasıdır. Süreç bu yüzden 	sürekli müşteriyle dirsek dirseğe olan yazılım ekibiyle daha hızlı ilerler. Diğer önemli bir kriter ise 	cesarettir bu model önünüze çıkılan engelleri aşmanızı ve yılmamanızı bekler. XP nin farklı 12 pratiği 	vardır 	haydi biraz da onlara göz gezdirelim. Planlama oyunu, ayakta toplantı, ekipte müşteri, kısa 	aralıklarla yeni sürüm, geriye bakış, metafor, ortak sorumluluk, sürekli entegrasyon, kod standartları, 	kalıcı tempo, test etme, sade tasarım, yeniden yapılandırma ve eşli programlamadır. 

 

Scrum : Bu metotun amacı zor projeleri basite indirgeyerek çözüme kavuşturmaktır. En önemli 	hususu proje yönetim yaklaşımı olduğu için sadece yazılım geliştirmeye değil her projeye 		uygulanabilir. Scrumda da XP gibi temel prensipler vardır. Scrum 3 temel üzerine dayanır. 

Şeffaflık : Projenin ilerleyişi, sorunları ve gelişmeleri herkes tarafından görülebilir olmalıdır. 

Denetleme : Projenin ilerleyişi sık sık kontrol edilir. 

Uyarlama : Proje, yapılacak değişimlere adaptasyon sağlamalıdır. 

 

Scrum Kavramları :  

1) Product Backlog : Türkçesi ürün gereksinimleri listesi olan adından da anlayacağımız üzere 	müşterinin ihtiyaçlarına göre hazırlanmış bir listedir. Projenin sonunda “Ne üreteceğiz?” sorusuna 	cevap aranır. Ürün sahibi listeye istediği gibi ekleme veya çıkarma işlemlerini uygulayabilir.  

2) Sprint Backlog : Proje sprint denilen küçük kısımlara ayrılır. Scrum içerisindeki tüm 	                   aktiviteler sprint içerisinde gerçekleşir. Bu sprintler 2-4 hafta arasında sürer. 

3) Daily Scrum : Her gün ayakta 15 dakika yapılan toplantılardır. Bu toplantıda gelecek 24 saat 	planlanır. Gruptaki her üye dün ne yaptım, bugün ne yapacağım ve beni engelleyen sorun var mı var ise	neler sorularına cevap arar. Eğer bir sorunla karşılaşılırsa scrum master duruma müdahele eder. 

 

Scrum Temelleri 

Roller  

1) Product Owner : Geliştirme takımı ile müşteri arasındaki iletişimi sağlayan kişidir. Product Backlog u oluşturan bu kişi isterse sprinti dahi iptal edebilir.  

2)  Scrum Master : Scrumun kurallarını eksik bilerek bu projede ekibin kurallara sadık kalmasına yardımcı olur. Takımdaki sıkıntıları ve engelleri çözüme götürür. 

3) Daily Scrum : Sprintteki işlerin hepsini bilen 5-7 kişi aralığında oluşan takımdır. Sprint Backlog’ u oluştururlar. Kişilere tek bir görev verilmemiştir herkes her işi yapabilecek donanımdadır. 


Toplantılar : 4 aşamadan oluşur : Sprint Planning, Daily Scrum, Sprint Review, Sprint Retrospective. 

Sprint Planning kısmında Product Backlog kısmında belirtilen gereksinimler, bu toplantı ile küçük parçalara ayrılır. Bu toplantıya Product Owner, Scrum Master ve Geliştirme Takımı katılır. 2-4 haftalık sprintler oluşturalarak toplantıya son verilir. 

Sprint Review her sprintin sonunda yapılır. Sprint gözden geçirelerek yazılımın ürün sahibinin                     gereksinimlerine uygun olup olmadığı kontrol edilir. Bir hata varsa düzeltilir. 

Sprint Retrospective sprint boyunca yapılan işlerin kalitesi, doğruları ve yanlışları konuşulur. Bundan 	sonra neleri daha iyi yapabiliriz sorusuna cevap aranır. 

 

Kapanış 

Bu yazının sonunda umarım ki öğrencilik veya iş hayatınızda kullanacağınız bu modellerin size en yakınını bulmuş ve benimsemişsinizdir. Yazılım okyanusunda size bir kum tanesi kadar bilgi katabildiysem ne mutlu bana. Sağlık ve yazılım ile kalın!  
